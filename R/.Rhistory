}
if(nangles < 1 | nangles %% 1 != 0){
stop("The number of angles needs to be a positive integer.")
}
if(alpha < 0 | alpha > 1){
stop("The significance level needs to be in [0, 1].")
}
if(alpha > 0.5){
warning("This will lead to a confidence interval smaller than 50%. Perhaps you mean 1-alpha.")
}
constrainedshape = retcurve@constrainedshape
result <- ReturnCurves:::rc_unc.class(retcurve = retcurve, blocksize = blocksize, nboot = nboot, nangles = nangles,
alpha = alpha, unc = list())
rc_origin <- result@retcurve@rc
data <- result@retcurve@data
w <- result@retcurve@w
qmarg <- result@retcurve@qmarg
p <- result@retcurve@p
method <- result@retcurve@method
q <- result@retcurve@q
qalphas <- result@retcurve@qalphas
k <- result@retcurve@k
constrained <- result@retcurve@constrained
tol <- result@retcurve@tol
n <- dim(data)[1]
angles <- ((nangles:1)/(nangles + 1)) * (pi/2)
grad <- tan(angles)
data0 <- apply(data, 2, min)
norms <- lapply(1:nangles, function(i) vector())
bootwarnmarg <- integer()
for(i in 1:nboot){
bootdata <- ReturnCurves:::block_bootstrap_function(data = data, k = blocksize, n = n)
margdataboot <- withCallingHandlers(margtransf(data = bootdata, qmarg = qmarg, constrainedshape = constrainedshape),
warning = function(war){
if(war$message == "MLE for the shape parameter of the GPD is < -1. \n Fitted endpoint is the maximum data point." | war$message == "MLE for the constrained shape parameter of the GPD is close to -1. \n Unconstrained MLE is likely to be < -1."){
bootwarnmarg <<- c(bootwarnmarg, i)
}
invokeRestart("muffleWarning")})
rc_data <- tryCatch(rc_est(margdata = margdataboot, w = w, p = p, method = method, q = q, qalphas = qalphas, k = k, constrained = constrained, tol = tol),
error = function(e){
message("Optimisation issues due infinite values. \n Try setting constrainedshape = TRUE when transforming the data to exponential."),
rc_unc <- function(retcurve, blocksize = 1, nboot = 250, nangles = 150, alpha = 0.05){
if(!inherits(retcurve, "rc_est.class")){
stop("The retcurve argument needs to be an object of class rc_est.class.")
}
if(nboot < 1 | nboot %% 1 != 0){
stop("The number of bootstrap samples needs to be a positive integer.")
}
if(nangles < 1 | nangles %% 1 != 0){
stop("The number of angles needs to be a positive integer.")
}
if(alpha < 0 | alpha > 1){
stop("The significance level needs to be in [0, 1].")
}
if(alpha > 0.5){
warning("This will lead to a confidence interval smaller than 50%. Perhaps you mean 1-alpha.")
}
constrainedshape = retcurve@constrainedshape
result <- ReturnCurves:::rc_unc.class(retcurve = retcurve, blocksize = blocksize, nboot = nboot, nangles = nangles,
alpha = alpha, unc = list())
rc_origin <- result@retcurve@rc
data <- result@retcurve@data
w <- result@retcurve@w
qmarg <- result@retcurve@qmarg
p <- result@retcurve@p
method <- result@retcurve@method
q <- result@retcurve@q
qalphas <- result@retcurve@qalphas
k <- result@retcurve@k
constrained <- result@retcurve@constrained
tol <- result@retcurve@tol
n <- dim(data)[1]
angles <- ((nangles:1)/(nangles + 1)) * (pi/2)
grad <- tan(angles)
data0 <- apply(data, 2, min)
norms <- lapply(1:nangles, function(i) vector())
bootwarnmarg <- integer()
for(i in 1:nboot){
bootdata <- ReturnCurves:::block_bootstrap_function(data = data, k = blocksize, n = n)
margdataboot <- withCallingHandlers(margtransf(data = bootdata, qmarg = qmarg, constrainedshape = constrainedshape),
warning = function(war){
if(war$message == "MLE for the shape parameter of the GPD is < -1. \n Fitted endpoint is the maximum data point." | war$message == "MLE for the constrained shape parameter of the GPD is close to -1. \n Unconstrained MLE is likely to be < -1."){
bootwarnmarg <<- c(bootwarnmarg, i)
}
invokeRestart("muffleWarning")})
rc_data <- tryCatch(rc_est(margdata = margdataboot, w = w, p = p, method = method, q = q, qalphas = qalphas, k = k, constrained = constrained, tol = tol),
error = function(e){
message("Optimisation issues due infinite values. \n Try setting constrainedshape = TRUE when transforming the data to exponential.")
stop(invisible(e))
})
rc_orig <- rc_data@rc
rc_orig <- rbind(c(data0[1], rc_orig[1, 2]), rc_orig, c(rc_orig[dim(rc_orig)[1], 1], data0[2]))
curve_w <- atan((rc_orig[, 2] - data0[2])/(rc_orig[, 1] - data0[1]))
for(j in 1:nangles){
idx <- min(which(angles[j] >= curve_w))
data1 <- rc_orig[idx, ] - data0
data2 <- rc_orig[idx - 1, ] - data0
s <- (data1[1] * tan(angles[j]) - data1[2])/((data2[2] - data1[2]) - (data2[1] - data1[1]) * tan(angles[j]))
xhat <- data1[1] + s*(data2[1] - data1[1])
yhat <- data1[2] + s*(data2[2] - data1[2])
norms[[j]][i] <- sqrt(xhat^2 + yhat^2)
}
}
if(length(bootwarnmarg) > 0){
warning(sprintf("In iterations %s of the bootstrap procedure: estimated GPD shape parameter is close to or smaller than -1. \n Fitted endpoint is likely to be the maximum data point.",
paste(bootwarnmarg, collapse = ", ")))
}
lb <- sapply(1:nangles, function(i) quantile(norms[[i]], alpha/2))
ub <- sapply(1:nangles, function(i) quantile(norms[[i]], 1 - alpha/2))
med <- sapply(1:nangles, function(i) quantile(norms[[i]], 0.5))
mea <- sapply(1:nangles, function(i) mean(norms[[i]]))
rc_mean <- cbind(mea/sqrt(1 + grad^2) + data0[1], grad * (mea/sqrt(1 + grad^2)) + data0[2])
rc_median <- cbind(med/sqrt(1 + grad^2) + data0[1], grad * (med/sqrt(1 + grad^2)) + data0[2])
rc_lb <- cbind(lb/sqrt(1 + grad^2) + data0[1], grad * (lb/sqrt(1 + grad^2)) + data0[2])
rc_ub <- cbind(ub/sqrt(1 + grad^2) + data0[1], grad * (ub/sqrt(1 + grad^2)) + data0[2])
result@unc <- list("median" = rc_median, "mean" = rc_mean, "lower" = rc_lb, "upper" = rc_ub)
return(result)
}
rc_unc_cl <- rc_unc(curve_cl)
?muffleError
?muffleWarning
?invokeRestart
rc_unc <- function(retcurve, blocksize = 1, nboot = 250, nangles = 150, alpha = 0.05){
if(!inherits(retcurve, "rc_est.class")){
stop("The retcurve argument needs to be an object of class rc_est.class.")
}
if(nboot < 1 | nboot %% 1 != 0){
stop("The number of bootstrap samples needs to be a positive integer.")
}
if(nangles < 1 | nangles %% 1 != 0){
stop("The number of angles needs to be a positive integer.")
}
if(alpha < 0 | alpha > 1){
stop("The significance level needs to be in [0, 1].")
}
if(alpha > 0.5){
warning("This will lead to a confidence interval smaller than 50%. Perhaps you mean 1-alpha.")
}
constrainedshape = retcurve@constrainedshape
result <- ReturnCurves:::rc_unc.class(retcurve = retcurve, blocksize = blocksize, nboot = nboot, nangles = nangles,
alpha = alpha, unc = list())
rc_origin <- result@retcurve@rc
data <- result@retcurve@data
w <- result@retcurve@w
qmarg <- result@retcurve@qmarg
p <- result@retcurve@p
method <- result@retcurve@method
q <- result@retcurve@q
qalphas <- result@retcurve@qalphas
k <- result@retcurve@k
constrained <- result@retcurve@constrained
tol <- result@retcurve@tol
n <- dim(data)[1]
angles <- ((nangles:1)/(nangles + 1)) * (pi/2)
grad <- tan(angles)
data0 <- apply(data, 2, min)
norms <- lapply(1:nangles, function(i) vector())
bootwarnmarg <- integer()
for(i in 1:nboot){
bootdata <- ReturnCurves:::block_bootstrap_function(data = data, k = blocksize, n = n)
margdataboot <- withCallingHandlers(margtransf(data = bootdata, qmarg = qmarg, constrainedshape = constrainedshape),
warning = function(war){
if(war$message == "MLE for the shape parameter of the GPD is < -1. \n Fitted endpoint is the maximum data point." | war$message == "MLE for the constrained shape parameter of the GPD is close to -1. \n Unconstrained MLE is likely to be < -1."){
bootwarnmarg <<- c(bootwarnmarg, i)
}
invokeRestart("muffleWarning")})
rc_data <- tryCatch(rc_est(margdata = margdataboot, w = w, p = p, method = method, q = q, qalphas = qalphas, k = k, constrained = constrained, tol = tol),
error = function(e){
message("Optimisation issues due infinite values. \n Try setting constrainedshape = TRUE when transforming the data to exponential.")
stop("")
})
rc_orig <- rc_data@rc
rc_orig <- rbind(c(data0[1], rc_orig[1, 2]), rc_orig, c(rc_orig[dim(rc_orig)[1], 1], data0[2]))
curve_w <- atan((rc_orig[, 2] - data0[2])/(rc_orig[, 1] - data0[1]))
for(j in 1:nangles){
idx <- min(which(angles[j] >= curve_w))
data1 <- rc_orig[idx, ] - data0
data2 <- rc_orig[idx - 1, ] - data0
s <- (data1[1] * tan(angles[j]) - data1[2])/((data2[2] - data1[2]) - (data2[1] - data1[1]) * tan(angles[j]))
xhat <- data1[1] + s*(data2[1] - data1[1])
yhat <- data1[2] + s*(data2[2] - data1[2])
norms[[j]][i] <- sqrt(xhat^2 + yhat^2)
}
}
if(length(bootwarnmarg) > 0){
warning(sprintf("In iterations %s of the bootstrap procedure: estimated GPD shape parameter is close to or smaller than -1. \n Fitted endpoint is likely to be the maximum data point.",
paste(bootwarnmarg, collapse = ", ")))
}
lb <- sapply(1:nangles, function(i) quantile(norms[[i]], alpha/2))
ub <- sapply(1:nangles, function(i) quantile(norms[[i]], 1 - alpha/2))
med <- sapply(1:nangles, function(i) quantile(norms[[i]], 0.5))
mea <- sapply(1:nangles, function(i) mean(norms[[i]]))
rc_mean <- cbind(mea/sqrt(1 + grad^2) + data0[1], grad * (mea/sqrt(1 + grad^2)) + data0[2])
rc_median <- cbind(med/sqrt(1 + grad^2) + data0[1], grad * (med/sqrt(1 + grad^2)) + data0[2])
rc_lb <- cbind(lb/sqrt(1 + grad^2) + data0[1], grad * (lb/sqrt(1 + grad^2)) + data0[2])
rc_ub <- cbind(ub/sqrt(1 + grad^2) + data0[1], grad * (ub/sqrt(1 + grad^2)) + data0[2])
result@unc <- list("median" = rc_median, "mean" = rc_mean, "lower" = rc_lb, "upper" = rc_ub)
return(result)
}
?invokeRestart
rc_unc_cl <- rc_unc(curve_cl)
rc_unc <- function(retcurve, blocksize = 1, nboot = 250, nangles = 150, alpha = 0.05){
if(!inherits(retcurve, "rc_est.class")){
stop("The retcurve argument needs to be an object of class rc_est.class.")
}
if(nboot < 1 | nboot %% 1 != 0){
stop("The number of bootstrap samples needs to be a positive integer.")
}
if(nangles < 1 | nangles %% 1 != 0){
stop("The number of angles needs to be a positive integer.")
}
if(alpha < 0 | alpha > 1){
stop("The significance level needs to be in [0, 1].")
}
if(alpha > 0.5){
warning("This will lead to a confidence interval smaller than 50%. Perhaps you mean 1-alpha.")
}
constrainedshape = retcurve@constrainedshape
result <- ReturnCurves:::rc_unc.class(retcurve = retcurve, blocksize = blocksize, nboot = nboot, nangles = nangles,
alpha = alpha, unc = list())
rc_origin <- result@retcurve@rc
data <- result@retcurve@data
w <- result@retcurve@w
qmarg <- result@retcurve@qmarg
p <- result@retcurve@p
method <- result@retcurve@method
q <- result@retcurve@q
qalphas <- result@retcurve@qalphas
k <- result@retcurve@k
constrained <- result@retcurve@constrained
tol <- result@retcurve@tol
n <- dim(data)[1]
angles <- ((nangles:1)/(nangles + 1)) * (pi/2)
grad <- tan(angles)
data0 <- apply(data, 2, min)
norms <- lapply(1:nangles, function(i) vector())
bootwarnmarg <- integer()
for(i in 1:nboot){
bootdata <- ReturnCurves:::block_bootstrap_function(data = data, k = blocksize, n = n)
margdataboot <- withCallingHandlers(margtransf(data = bootdata, qmarg = qmarg, constrainedshape = constrainedshape),
warning = function(war){
if(war$message == "MLE for the shape parameter of the GPD is < -1. \n Fitted endpoint is the maximum data point." | war$message == "MLE for the constrained shape parameter of the GPD is close to -1. \n Unconstrained MLE is likely to be < -1."){
bootwarnmarg <<- c(bootwarnmarg, i)
}
invokeRestart("muffleWarning")})
rc_data <- tryCatch(rc_est(margdata = margdataboot, w = w, p = p, method = method, q = q, qalphas = qalphas, k = k, constrained = constrained, tol = tol),
error = function(e){
warning("Optimisation issues due infinite values. \n Try setting constrainedshape = TRUE when transforming the data to exponential.")
})
rc_orig <- rc_data@rc
rc_orig <- rbind(c(data0[1], rc_orig[1, 2]), rc_orig, c(rc_orig[dim(rc_orig)[1], 1], data0[2]))
curve_w <- atan((rc_orig[, 2] - data0[2])/(rc_orig[, 1] - data0[1]))
for(j in 1:nangles){
idx <- min(which(angles[j] >= curve_w))
data1 <- rc_orig[idx, ] - data0
data2 <- rc_orig[idx - 1, ] - data0
s <- (data1[1] * tan(angles[j]) - data1[2])/((data2[2] - data1[2]) - (data2[1] - data1[1]) * tan(angles[j]))
xhat <- data1[1] + s*(data2[1] - data1[1])
yhat <- data1[2] + s*(data2[2] - data1[2])
norms[[j]][i] <- sqrt(xhat^2 + yhat^2)
}
}
if(length(bootwarnmarg) > 0){
warning(sprintf("In iterations %s of the bootstrap procedure: estimated GPD shape parameter is close to or smaller than -1. \n Fitted endpoint is likely to be the maximum data point.",
paste(bootwarnmarg, collapse = ", ")))
}
lb <- sapply(1:nangles, function(i) quantile(norms[[i]], alpha/2))
ub <- sapply(1:nangles, function(i) quantile(norms[[i]], 1 - alpha/2))
med <- sapply(1:nangles, function(i) quantile(norms[[i]], 0.5))
mea <- sapply(1:nangles, function(i) mean(norms[[i]]))
rc_mean <- cbind(mea/sqrt(1 + grad^2) + data0[1], grad * (mea/sqrt(1 + grad^2)) + data0[2])
rc_median <- cbind(med/sqrt(1 + grad^2) + data0[1], grad * (med/sqrt(1 + grad^2)) + data0[2])
rc_lb <- cbind(lb/sqrt(1 + grad^2) + data0[1], grad * (lb/sqrt(1 + grad^2)) + data0[2])
rc_ub <- cbind(ub/sqrt(1 + grad^2) + data0[1], grad * (ub/sqrt(1 + grad^2)) + data0[2])
result@unc <- list("median" = rc_median, "mean" = rc_mean, "lower" = rc_lb, "upper" = rc_ub)
return(result)
}
rc_unc_cl <- rc_unc(curve_cl)
rc_unc <- function(retcurve, blocksize = 1, nboot = 250, nangles = 150, alpha = 0.05){
if(!inherits(retcurve, "rc_est.class")){
stop("The retcurve argument needs to be an object of class rc_est.class.")
}
if(nboot < 1 | nboot %% 1 != 0){
stop("The number of bootstrap samples needs to be a positive integer.")
}
if(nangles < 1 | nangles %% 1 != 0){
stop("The number of angles needs to be a positive integer.")
}
if(alpha < 0 | alpha > 1){
stop("The significance level needs to be in [0, 1].")
}
if(alpha > 0.5){
warning("This will lead to a confidence interval smaller than 50%. Perhaps you mean 1-alpha.")
}
constrainedshape = retcurve@constrainedshape
result <- ReturnCurves:::rc_unc.class(retcurve = retcurve, blocksize = blocksize, nboot = nboot, nangles = nangles,
alpha = alpha, unc = list())
rc_origin <- result@retcurve@rc
data <- result@retcurve@data
w <- result@retcurve@w
qmarg <- result@retcurve@qmarg
p <- result@retcurve@p
method <- result@retcurve@method
q <- result@retcurve@q
qalphas <- result@retcurve@qalphas
k <- result@retcurve@k
constrained <- result@retcurve@constrained
tol <- result@retcurve@tol
n <- dim(data)[1]
angles <- ((nangles:1)/(nangles + 1)) * (pi/2)
grad <- tan(angles)
data0 <- apply(data, 2, min)
norms <- lapply(1:nangles, function(i) vector())
bootwarnmarg <- integer()
for(i in 1:nboot){
bootdata <- ReturnCurves:::block_bootstrap_function(data = data, k = blocksize, n = n)
margdataboot <- withCallingHandlers(margtransf(data = bootdata, qmarg = qmarg, constrainedshape = constrainedshape),
warning = function(war){
if(war$message == "MLE for the shape parameter of the GPD is < -1. \n Fitted endpoint is the maximum data point." | war$message == "MLE for the constrained shape parameter of the GPD is close to -1. \n Unconstrained MLE is likely to be < -1."){
bootwarnmarg <<- c(bootwarnmarg, i)
}
invokeRestart("muffleWarning")})
rc_data <- tryCatch(rc_est(margdata = margdataboot, w = w, p = p, method = method, q = q, qalphas = qalphas, k = k, constrained = constrained, tol = tol),
error = function(e){
warning("Optimisation issues due infinite values. \n Try setting constrainedshape = TRUE when transforming the data to exponential.")
stop(invisible(e))
})
rc_orig <- rc_data@rc
rc_orig <- rbind(c(data0[1], rc_orig[1, 2]), rc_orig, c(rc_orig[dim(rc_orig)[1], 1], data0[2]))
curve_w <- atan((rc_orig[, 2] - data0[2])/(rc_orig[, 1] - data0[1]))
for(j in 1:nangles){
idx <- min(which(angles[j] >= curve_w))
data1 <- rc_orig[idx, ] - data0
data2 <- rc_orig[idx - 1, ] - data0
s <- (data1[1] * tan(angles[j]) - data1[2])/((data2[2] - data1[2]) - (data2[1] - data1[1]) * tan(angles[j]))
xhat <- data1[1] + s*(data2[1] - data1[1])
yhat <- data1[2] + s*(data2[2] - data1[2])
norms[[j]][i] <- sqrt(xhat^2 + yhat^2)
}
}
if(length(bootwarnmarg) > 0){
warning(sprintf("In iterations %s of the bootstrap procedure: estimated GPD shape parameter is close to or smaller than -1. \n Fitted endpoint is likely to be the maximum data point.",
paste(bootwarnmarg, collapse = ", ")))
}
lb <- sapply(1:nangles, function(i) quantile(norms[[i]], alpha/2))
ub <- sapply(1:nangles, function(i) quantile(norms[[i]], 1 - alpha/2))
med <- sapply(1:nangles, function(i) quantile(norms[[i]], 0.5))
mea <- sapply(1:nangles, function(i) mean(norms[[i]]))
rc_mean <- cbind(mea/sqrt(1 + grad^2) + data0[1], grad * (mea/sqrt(1 + grad^2)) + data0[2])
rc_median <- cbind(med/sqrt(1 + grad^2) + data0[1], grad * (med/sqrt(1 + grad^2)) + data0[2])
rc_lb <- cbind(lb/sqrt(1 + grad^2) + data0[1], grad * (lb/sqrt(1 + grad^2)) + data0[2])
rc_ub <- cbind(ub/sqrt(1 + grad^2) + data0[1], grad * (ub/sqrt(1 + grad^2)) + data0[2])
result@unc <- list("median" = rc_median, "mean" = rc_mean, "lower" = rc_lb, "upper" = rc_ub)
return(result)
}
rc_unc_cl <- rc_unc(curve_cl)
rc_unc <- function(retcurve, blocksize = 1, nboot = 250, nangles = 150, alpha = 0.05){
if(!inherits(retcurve, "rc_est.class")){
stop("The retcurve argument needs to be an object of class rc_est.class.")
}
if(nboot < 1 | nboot %% 1 != 0){
stop("The number of bootstrap samples needs to be a positive integer.")
}
if(nangles < 1 | nangles %% 1 != 0){
stop("The number of angles needs to be a positive integer.")
}
if(alpha < 0 | alpha > 1){
stop("The significance level needs to be in [0, 1].")
}
if(alpha > 0.5){
warning("This will lead to a confidence interval smaller than 50%. Perhaps you mean 1-alpha.")
}
constrainedshape = retcurve@constrainedshape
result <- ReturnCurves:::rc_unc.class(retcurve = retcurve, blocksize = blocksize, nboot = nboot, nangles = nangles,
alpha = alpha, unc = list())
rc_origin <- result@retcurve@rc
data <- result@retcurve@data
w <- result@retcurve@w
qmarg <- result@retcurve@qmarg
p <- result@retcurve@p
method <- result@retcurve@method
q <- result@retcurve@q
qalphas <- result@retcurve@qalphas
k <- result@retcurve@k
constrained <- result@retcurve@constrained
tol <- result@retcurve@tol
n <- dim(data)[1]
angles <- ((nangles:1)/(nangles + 1)) * (pi/2)
grad <- tan(angles)
data0 <- apply(data, 2, min)
norms <- lapply(1:nangles, function(i) vector())
bootwarnmarg <- integer()
for(i in 1:nboot){
bootdata <- ReturnCurves:::block_bootstrap_function(data = data, k = blocksize, n = n)
margdataboot <- withCallingHandlers(margtransf(data = bootdata, qmarg = qmarg, constrainedshape = constrainedshape),
warning = function(war){
if(war$message == "MLE for the shape parameter of the GPD is < -1. \n Fitted endpoint is the maximum data point." | war$message == "MLE for the constrained shape parameter of the GPD is close to -1. \n Unconstrained MLE is likely to be < -1."){
bootwarnmarg <<- c(bootwarnmarg, i)
}
invokeRestart("muffleWarning")})
rc_data <- tryCatch(rc_est(margdata = margdataboot, w = w, p = p, method = method, q = q, qalphas = qalphas, k = k, constrained = constrained, tol = tol),
error = function(e){
cat(conditionMessage(e), " \n Optimisation issues due infinite values. \n Try setting constrainedshape = TRUE when transforming the data to exponential.")
#stop(invisible(e))
})
rc_orig <- rc_data@rc
rc_orig <- rbind(c(data0[1], rc_orig[1, 2]), rc_orig, c(rc_orig[dim(rc_orig)[1], 1], data0[2]))
curve_w <- atan((rc_orig[, 2] - data0[2])/(rc_orig[, 1] - data0[1]))
for(j in 1:nangles){
idx <- min(which(angles[j] >= curve_w))
data1 <- rc_orig[idx, ] - data0
data2 <- rc_orig[idx - 1, ] - data0
s <- (data1[1] * tan(angles[j]) - data1[2])/((data2[2] - data1[2]) - (data2[1] - data1[1]) * tan(angles[j]))
xhat <- data1[1] + s*(data2[1] - data1[1])
yhat <- data1[2] + s*(data2[2] - data1[2])
norms[[j]][i] <- sqrt(xhat^2 + yhat^2)
}
}
if(length(bootwarnmarg) > 0){
warning(sprintf("In iterations %s of the bootstrap procedure: estimated GPD shape parameter is close to or smaller than -1. \n Fitted endpoint is likely to be the maximum data point.",
paste(bootwarnmarg, collapse = ", ")))
}
lb <- sapply(1:nangles, function(i) quantile(norms[[i]], alpha/2))
ub <- sapply(1:nangles, function(i) quantile(norms[[i]], 1 - alpha/2))
med <- sapply(1:nangles, function(i) quantile(norms[[i]], 0.5))
mea <- sapply(1:nangles, function(i) mean(norms[[i]]))
rc_mean <- cbind(mea/sqrt(1 + grad^2) + data0[1], grad * (mea/sqrt(1 + grad^2)) + data0[2])
rc_median <- cbind(med/sqrt(1 + grad^2) + data0[1], grad * (med/sqrt(1 + grad^2)) + data0[2])
rc_lb <- cbind(lb/sqrt(1 + grad^2) + data0[1], grad * (lb/sqrt(1 + grad^2)) + data0[2])
rc_ub <- cbind(ub/sqrt(1 + grad^2) + data0[1], grad * (ub/sqrt(1 + grad^2)) + data0[2])
result@unc <- list("median" = rc_median, "mean" = rc_mean, "lower" = rc_lb, "upper" = rc_ub)
return(result)
}
rc_unc_cl <- rc_unc(curve_cl)
rc_unc <- function(retcurve, blocksize = 1, nboot = 250, nangles = 150, alpha = 0.05){
if(!inherits(retcurve, "rc_est.class")){
stop("The retcurve argument needs to be an object of class rc_est.class.")
}
if(nboot < 1 | nboot %% 1 != 0){
stop("The number of bootstrap samples needs to be a positive integer.")
}
if(nangles < 1 | nangles %% 1 != 0){
stop("The number of angles needs to be a positive integer.")
}
if(alpha < 0 | alpha > 1){
stop("The significance level needs to be in [0, 1].")
}
if(alpha > 0.5){
warning("This will lead to a confidence interval smaller than 50%. Perhaps you mean 1-alpha.")
}
constrainedshape = retcurve@constrainedshape
result <- ReturnCurves:::rc_unc.class(retcurve = retcurve, blocksize = blocksize, nboot = nboot, nangles = nangles,
alpha = alpha, unc = list())
rc_origin <- result@retcurve@rc
data <- result@retcurve@data
w <- result@retcurve@w
qmarg <- result@retcurve@qmarg
p <- result@retcurve@p
method <- result@retcurve@method
q <- result@retcurve@q
qalphas <- result@retcurve@qalphas
k <- result@retcurve@k
constrained <- result@retcurve@constrained
tol <- result@retcurve@tol
n <- dim(data)[1]
angles <- ((nangles:1)/(nangles + 1)) * (pi/2)
grad <- tan(angles)
data0 <- apply(data, 2, min)
norms <- lapply(1:nangles, function(i) vector())
bootwarnmarg <- integer()
for(i in 1:nboot){
bootdata <- ReturnCurves:::block_bootstrap_function(data = data, k = blocksize, n = n)
margdataboot <- withCallingHandlers(margtransf(data = bootdata, qmarg = qmarg, constrainedshape = constrainedshape),
warning = function(war){
if(war$message == "MLE for the shape parameter of the GPD is < -1. \n Fitted endpoint is the maximum data point." | war$message == "MLE for the constrained shape parameter of the GPD is close to -1. \n Unconstrained MLE is likely to be < -1."){
bootwarnmarg <<- c(bootwarnmarg, i)
}
invokeRestart("muffleWarning")})
rc_data <- tryCatch(rc_est(margdata = margdataboot, w = w, p = p, method = method, q = q, qalphas = qalphas, k = k, constrained = constrained, tol = tol),
error = function(e){
message("Optimisation issues due infinite values. \n Try setting constrainedshape = TRUE when transforming the data to exponential.")
stop(invisible(e))
})
rc_orig <- rc_data@rc
rc_orig <- rbind(c(data0[1], rc_orig[1, 2]), rc_orig, c(rc_orig[dim(rc_orig)[1], 1], data0[2]))
curve_w <- atan((rc_orig[, 2] - data0[2])/(rc_orig[, 1] - data0[1]))
for(j in 1:nangles){
idx <- min(which(angles[j] >= curve_w))
data1 <- rc_orig[idx, ] - data0
data2 <- rc_orig[idx - 1, ] - data0
s <- (data1[1] * tan(angles[j]) - data1[2])/((data2[2] - data1[2]) - (data2[1] - data1[1]) * tan(angles[j]))
xhat <- data1[1] + s*(data2[1] - data1[1])
yhat <- data1[2] + s*(data2[2] - data1[2])
norms[[j]][i] <- sqrt(xhat^2 + yhat^2)
}
}
if(length(bootwarnmarg) > 0){
warning(sprintf("In iterations %s of the bootstrap procedure: estimated GPD shape parameter is close to or smaller than -1. \n Fitted endpoint is likely to be the maximum data point.",
paste(bootwarnmarg, collapse = ", ")))
}
lb <- sapply(1:nangles, function(i) quantile(norms[[i]], alpha/2))
ub <- sapply(1:nangles, function(i) quantile(norms[[i]], 1 - alpha/2))
med <- sapply(1:nangles, function(i) quantile(norms[[i]], 0.5))
mea <- sapply(1:nangles, function(i) mean(norms[[i]]))
rc_mean <- cbind(mea/sqrt(1 + grad^2) + data0[1], grad * (mea/sqrt(1 + grad^2)) + data0[2])
rc_median <- cbind(med/sqrt(1 + grad^2) + data0[1], grad * (med/sqrt(1 + grad^2)) + data0[2])
rc_lb <- cbind(lb/sqrt(1 + grad^2) + data0[1], grad * (lb/sqrt(1 + grad^2)) + data0[2])
rc_ub <- cbind(ub/sqrt(1 + grad^2) + data0[1], grad * (ub/sqrt(1 + grad^2)) + data0[2])
result@unc <- list("median" = rc_median, "mean" = rc_mean, "lower" = rc_lb, "upper" = rc_ub)
return(result)
}
rc_unc_cl <- rc_unc(curve_cl)
